"""
Tests complets pour le module Cuisine
"""

import pytest
import asyncio
from datetime import datetime

from src.core.models import Recipe, Ingredient, RecipeIngredient, InventoryItem
from src.core.database import get_db_context
from src.core.ai_agent import AgentIA


# ===================================
# FIXTURES
# ===================================


@pytest.fixture
def sample_ingredients(db_session):
    """Crée des ingrédients de test"""
    ingredients = [
        Ingredient(name="Tomates", unit="pcs", category="Légumes"),
        Ingredient(name="Pâtes", unit="g", category="Féculents"),
        Ingredient(name="Fromage", unit="g", category="Laitier"),
        Ingredient(name="Oeufs", unit="pcs", category="Protéines"),
    ]

    for ing in ingredients:
        db_session.add(ing)

    db_session.commit()
    return ingredients


@pytest.fixture
def sample_recipe(db_session, sample_ingredients):
    """Crée une recette de test"""
    recipe = Recipe(
        name="Pâtes à la tomate",
        category="Plat",
        instructions="1. Cuire les pâtes\n2. Ajouter la sauce",
        prep_time=10,
        cook_time=15,
        servings=4,
    )
    db_session.add(recipe)
    db_session.commit()

    # Ajouter des ingrédients
    recipe_ing1 = RecipeIngredient(
        recipe_id=recipe.id,
        ingredient_id=sample_ingredients[0].id,  # Tomates
        quantity=3,
        unit="pcs",
    )
    recipe_ing2 = RecipeIngredient(
        recipe_id=recipe.id, ingredient_id=sample_ingredients[1].id, quantity=400, unit="g"  # Pâtes
    )

    db_session.add(recipe_ing1)
    db_session.add(recipe_ing2)
    db_session.commit()

    return recipe


@pytest.fixture
def sample_inventory(db_session, sample_ingredients):
    """Crée un inventaire de test"""
    inventory = [
        InventoryItem(
            ingredient_id=sample_ingredients[0].id, quantity=5, min_quantity=2  # Tomates
        ),
        InventoryItem(
            ingredient_id=sample_ingredients[1].id, quantity=500, min_quantity=200  # Pâtes
        ),
        InventoryItem(
            ingredient_id=sample_ingredients[2].id,  # Fromage
            quantity=1,  # Stock bas
            min_quantity=2,
        ),
    ]

    for item in inventory:
        db_session.add(item)

    db_session.commit()
    return inventory


# ===================================
# TESTS MODÈLES
# ===================================


class TestRecipeModel:
    """Tests du modèle Recipe"""

    def test_create_recipe(self, db_session):
        """Test création d'une recette"""
        recipe = Recipe(
            name="Test Recette",
            category="Plat",
            instructions="Instructions test",
            prep_time=20,
            cook_time=30,
            servings=4,
        )
        db_session.add(recipe)
        db_session.commit()

        assert recipe.id is not None
        assert recipe.name == "Test Recette"
        assert recipe.prep_time == 20

    def test_recipe_with_ingredients(self, db_session, sample_recipe, sample_ingredients):
        """Test recette avec ingrédients"""
        recipe = sample_recipe

        assert len(recipe.ingredients) == 2
        assert recipe.ingredients[0].ingredient.name == "Tomates"

    def test_ai_generated_recipe(self, db_session):
        """Test recette générée par IA"""
        recipe = Recipe(
            name="IA Recipe",
            category="Plat",
            instructions="Generated by AI",
            ai_generated=True,
            ai_score=85.5,
        )
        db_session.add(recipe)
        db_session.commit()

        assert recipe.ai_generated is True
        assert recipe.ai_score == 85.5


class TestIngredientModel:
    """Tests du modèle Ingredient"""

    def test_create_ingredient(self, db_session):
        """Test création d'un ingrédient"""
        ingredient = Ingredient(name="Test Ingredient", unit="kg", category="Test")
        db_session.add(ingredient)
        db_session.commit()

        assert ingredient.id is not None
        assert ingredient.name == "Test Ingredient"

    def test_ingredient_unique_name(self, db_session, sample_ingredients):
        """Test unicité du nom d'ingrédient"""
        # Tenter de créer un doublon
        with pytest.raises(Exception):  # IntegrityError
            duplicate = Ingredient(name="Tomates", unit="kg")  # Déjà existe
            db_session.add(duplicate)
            db_session.commit()


class TestInventoryModel:
    """Tests du modèle InventoryItem"""

    def test_create_inventory_item(self, db_session, sample_ingredients):
        """Test création d'un item d'inventaire"""
        item = InventoryItem(ingredient_id=sample_ingredients[0].id, quantity=10, min_quantity=2)
        db_session.add(item)
        db_session.commit()

        assert item.id is not None
        assert item.quantity == 10

    def test_low_stock_detection(self, db_session, sample_inventory):
        """Test détection de stock bas"""
        low_stock = (
            db_session.query(InventoryItem)
            .filter(InventoryItem.quantity < InventoryItem.min_quantity)
            .all()
        )

        assert len(low_stock) == 1
        assert low_stock[0].ingredient.name == "Fromage"


# ===================================
# TESTS AGENT IA
# ===================================


class TestAgentIARecipes:
    """Tests de l'agent IA pour les recettes"""

    @pytest.mark.asyncio
    async def test_suggerer_recettes(self, sample_inventory):
        """Test suggestion de recettes par IA"""
        agent = AgentIA()

        inventaire = [
            {"nom": "Tomates", "quantite": 5, "unite": "pcs"},
            {"nom": "Pâtes", "quantite": 500, "unite": "g"},
        ]

        suggestions = await agent.suggerer_recettes(inventaire=inventaire, nb_suggestions=2)

        assert isinstance(suggestions, list)
        assert len(suggestions) <= 2

        # Vérifier la structure
        if suggestions:
            sugg = suggestions[0]
            assert "nom" in sugg
            assert "ingredients" in sugg
            assert "faisabilite" in sugg

    @pytest.mark.asyncio
    async def test_detecter_gaspillage(self, sample_inventory):
        """Test détection de gaspillage"""
        agent = AgentIA()

        inventaire = [
            {"nom": "Fromage", "quantite": 1, "unite": "g"},  # Faible
        ]

        result = await agent.detecter_gaspillage(inventaire)

        assert "statut" in result
        assert result["statut"] == "ATTENTION"
        assert "items" in result or "recettes_urgentes" in result

    @pytest.mark.asyncio
    async def test_optimiser_courses(self):
        """Test optimisation de la liste de courses"""
        agent = AgentIA()

        inventaire = [
            {"nom": "Lait", "quantite": 0.2, "unite": "L"},
        ]

        recettes_prevues = ["Gratin dauphinois", "Crêpes"]

        result = await agent.optimiser_courses(
            inventaire=inventaire, recettes_prevues=recettes_prevues
        )

        assert isinstance(result, dict)
        assert "par_rayon" in result or "budget_estime" in result


# ===================================
# TESTS FONCTIONNELS
# ===================================


class TestRecipeWorkflow:
    """Tests de workflows complets"""

    def test_create_and_retrieve_recipe(self, db_session, sample_ingredients):
        """Test création et récupération d'une recette"""
        # Créer
        recipe = Recipe(
            name="Omelette",
            category="Plat",
            instructions="Battre les oeufs, cuire",
            prep_time=5,
            cook_time=10,
            servings=2,
        )
        db_session.add(recipe)
        db_session.commit()
        recipe_id = recipe.id

        # Ajouter ingrédients
        recipe_ing = RecipeIngredient(
            recipe_id=recipe_id,
            ingredient_id=sample_ingredients[3].id,  # Oeufs
            quantity=3,
            unit="pcs",
        )
        db_session.add(recipe_ing)
        db_session.commit()

        # Récupérer
        retrieved = db_session.query(Recipe).filter(Recipe.id == recipe_id).first()

        assert retrieved is not None
        assert retrieved.name == "Omelette"
        assert len(retrieved.ingredients) == 1

    def test_search_recipes_by_category(self, db_session, sample_recipe):
        """Test recherche de recettes par catégorie"""
        recipes = db_session.query(Recipe).filter(Recipe.category == "Plat").all()

        assert len(recipes) >= 1
        assert all(r.category == "Plat" for r in recipes)

    def test_check_recipe_feasibility(self, db_session, sample_recipe, sample_inventory):
        """Test vérification de faisabilité d'une recette"""
        recipe = sample_recipe

        # Récupérer les ingrédients nécessaires
        needed = (
            db_session.query(Ingredient.name, RecipeIngredient.quantity)
            .join(RecipeIngredient, Ingredient.id == RecipeIngredient.ingredient_id)
            .filter(RecipeIngredient.recipe_id == recipe.id)
            .all()
        )

        # Vérifier disponibilité
        for ing_name, qty_needed in needed:
            inventory = (
                db_session.query(InventoryItem)
                .join(Ingredient)
                .filter(Ingredient.name == ing_name)
                .first()
            )

            if inventory:
                assert inventory.quantity >= qty_needed, f"Stock insuffisant pour {ing_name}"


class TestInventoryWorkflow:
    """Tests de workflows d'inventaire"""

    def test_update_inventory_after_cooking(self, db_session, sample_recipe, sample_inventory):
        """Test mise à jour de l'inventaire après avoir cuisiné"""
        recipe = sample_recipe

        # Récupérer les ingrédients utilisés
        ingredients_used = (
            db_session.query(Ingredient.id, RecipeIngredient.quantity)
            .join(RecipeIngredient, Ingredient.id == RecipeIngredient.ingredient_id)
            .filter(RecipeIngredient.recipe_id == recipe.id)
            .all()
        )

        # Déduire de l'inventaire
        for ing_id, qty_used in ingredients_used:
            inventory_item = (
                db_session.query(InventoryItem)
                .filter(InventoryItem.ingredient_id == ing_id)
                .first()
            )

            if inventory_item:
                old_qty = inventory_item.quantity
                inventory_item.quantity -= qty_used
                inventory_item.quantity = max(0, inventory_item.quantity)
                db_session.commit()

                # Vérifier
                assert inventory_item.quantity < old_qty

    def test_alert_low_stock(self, db_session, sample_inventory):
        """Test alertes de stock bas"""
        low_stock_items = (
            db_session.query(InventoryItem)
            .filter(InventoryItem.quantity < InventoryItem.min_quantity)
            .all()
        )

        assert len(low_stock_items) > 0

        for item in low_stock_items:
            assert item.quantity < item.min_quantity
            # L'alerte devrait être envoyée
            assert item.ai_alert_sent is False  # Pas encore envoyée


# ===================================
# TESTS D'INTÉGRATION
# ===================================


class TestRecipeAIIntegration:
    """Tests d'intégration IA + Base de données"""

    @pytest.mark.asyncio
    async def test_full_ai_suggestion_workflow(self, db_session, sample_inventory):
        """Test workflow complet : inventaire → IA → sauvegarde"""
        agent = AgentIA()

        # 1. Récupérer l'inventaire
        inventory_items = (
            db_session.query(Ingredient.name, InventoryItem.quantity, Ingredient.unit)
            .join(InventoryItem, Ingredient.id == InventoryItem.ingredient_id)
            .all()
        )

        inventaire = [
            {"nom": item.name, "quantite": item.quantity, "unite": item.unit}
            for item in inventory_items
        ]

        # 2. Demander des suggestions à l'IA
        suggestions = await agent.suggerer_recettes(inventaire=inventaire, nb_suggestions=1)

        assert len(suggestions) > 0

        # 3. Sauvegarder la première suggestion
        sugg = suggestions[0]

        recipe = Recipe(
            name=sugg["nom"],
            category="Suggestion IA",
            instructions="Généré automatiquement",
            ai_generated=True,
            ai_score=sugg.get("faisabilite", 0),
        )
        db_session.add(recipe)
        db_session.commit()

        # 4. Vérifier la sauvegarde
        saved = db_session.query(Recipe).filter(Recipe.name == sugg["nom"]).first()

        assert saved is not None
        assert saved.ai_generated is True


# ===================================
# TESTS DE PERFORMANCE
# ===================================


class TestPerformance:
    """Tests de performance"""

    def test_load_many_recipes(self, db_session):
        """Test chargement de nombreuses recettes"""
        # Créer 100 recettes
        for i in range(100):
            recipe = Recipe(name=f"Recipe {i}", category="Test", instructions="Test instructions")
            db_session.add(recipe)

        db_session.commit()

        # Mesurer le temps de chargement
        import time

        start = time.time()

        recipes = db_session.query(Recipe).all()

        elapsed = time.time() - start

        assert len(recipes) >= 100
        assert elapsed < 1.0  # Doit charger en moins d'1 seconde

    @pytest.mark.asyncio
    async def test_ai_response_time(self):
        """Test temps de réponse de l'IA"""
        agent = AgentIA()

        inventaire = [
            {"nom": "Tomates", "quantite": 3, "unite": "pcs"},
        ]

        import time

        start = time.time()

        try:
            suggestions = await agent.suggerer_recettes(inventaire=inventaire, nb_suggestions=1)
            elapsed = time.time() - start

            # L'IA devrait répondre en moins de 10 secondes
            assert elapsed < 10.0
        except Exception:
            # Si Ollama n'est pas disponible, le test passe
            pytest.skip("Ollama non disponible")
